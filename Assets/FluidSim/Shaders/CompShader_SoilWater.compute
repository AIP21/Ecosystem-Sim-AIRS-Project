#pragma kernel reset
#pragma kernel computeFlux
#pragma kernel computeFlow
#pragma kernel applyFreeSlip
#pragma kernel computeSatuation

Texture2D<float4> heightmap;
Texture2D<float4> soilDataMap;

RWTexture2D<float> saturationMap;
RWTexture2D<float> newSaturationMap;
RWTexture2D<float> surfaceWaterMap;
RWTexture2D<float> newSurfaceWaterMap;
RWTexture2D<float4> flowMap; // each float in the float4 is a direction of flow (up, down, left, right)
RWTexture2D<float4> newFlowMap;
RWTexture2D<float4> fluxMap; // r = soil holding capacity (affects absorption rate (absorptivity), evaporation rate, flow rate, and max holding capacity), g = soil use
RWTexture2D<float4> newFluxMap;

// Variables
float size;
float surfaceAbsorptionStrength;
float gravityAcceleration;
float pipeLength;
float pipeArea; // should be the pipe length squared
float epsilon;
float heightmapMultiplier;
float _deltaTime;

// Total height of a cell (height from heightmap + water height)
float totalHeight(int2 pos)
{
    float4 height = heightmap[pos];
    return ((height.x + height.y + height.z + height.w) * heightmapMultiplier) + saturationMap[pos];
}

// Returns the calculated flow
float flowToNeighbor(float flow, float heightDifference, float soilDensity)
{
    return max(0.0, flow + _deltaTime * pipeArea * ((soilDensity * gravityAcceleration * heightDifference) / (soilDensity * pipeLength)));
}

// Gaussian blur function
float gaussFactor(float2 diff, float radius)
{
    return exp(-(diff.x * diff.x + diff.y * diff.y) / radius);
}

// Reset the textures
[numthreads(8,8,1)]
void reset (uint3 id : SV_DispatchThreadid)
{
    saturationMap[id.xy] = 0;
    newSaturationMap[id.xy] = 0;
    flowMap[id.xy] = float4(0, 0, 0, 0);
    newFlowMap[id.xy] = float4(0, 0, 0, 0);
}

// Handle absoprtion from surface
[numthreads(8,8,1)]
void computeAbsorption (uint3 id : SV_DispatchThreadid)
{
    float2 pos = id.xy / size;

    float surfaceWater = surfaceWaterMap[id.xy];

    float soilHoldingCapacity = soilDataMap[id.xy].r;
    
    // Calculate the water this cell will absorb from the surface
    // This takes into account the soil holding capacity, the current saturation, and the surface water, along with the strength of the absorption
    float absorption = min(surfaceWater, soilHoldingCapacity - saturationMap[id.xy]) * surfaceAbsorptionStrength;

    // Update the saturation and surface water
    newSaturationMap[id.xy] = saturationMap[id.xy] + absorption;
    newSurfaceWaterMap[id.xy] = surfaceWater - absorption;
}

// Compute evaporation of water
[numthreads(8,8,1)]
void computeEvaporation (uint3 id : SV_DispatchThreadid)
{
    newWaterMap[id.xy] = max(waterMap[id.xy] - evaporationConstant, 0.0);
}

// Apply free slip to prevent issues at the borders
[numthreads(8,8,1)]
void applyFreeSlip (uint3 id : SV_DispatchThreadid)
{
    // Check if on border
    if (id.x == 0) { // left border
        newWaterMap[id.xy] = waterMap[id.xy + int2(1, 0)];
    }
    else if (id.y == 0) { // bottom border
        newWaterMap[id.xy] = waterMap[id.xy + int2(0, 1)];
    }
    else if (int(id.x) == size - 1) { // right border
        newWaterMap[id.xy] = waterMap[id.xy + int2(-1, 0)];
    }
    else if (int(id.y) == size - 1) { // top border
        newWaterMap[id.xy] = waterMap[id.xy + int2(0, -1)];
    }
}

// Compute the Flow
[numthreads(8,8,1)]
void computeWaterFlow (uint3 id : SV_DispatchThreadID)
{
    float2 pos = id.xy;

    // Height differences between this cell and the neighbor cells
    float height = totalHeight(pos);
    float heightDiffUp = height - totalHeight(pos + float2(0, 1));
    float heightDiffDown = height - totalHeight(pos + float2(0, -1));
    float heightDiffLeft = height - totalHeight(pos + float2(-1, 0));
    float heightDiffRight = height - totalHeight(pos + float2(1, 0));

    // Calculate flow from this cell into each neighbor cell
    float4 oldFlow = flowMap[pos] * flowDamping;
    float flowUp = flowToNeighbor(oldFlow.x, heightDiffUp);
    float flowDown = flowToNeighbor(oldFlow.y, heightDiffDown);
    float flowLeft = flowToNeighbor(oldFlow.z, heightDiffLeft);
    float flowRight = flowToNeighbor(oldFlow.w, heightDiffRight);

    // Calculate the output volume
    float outputVolume = _deltaTime * (flowUp + flowDown + flowLeft + flowRight);

    // Scale down the final flow if the output volume is larger than the amount of water in this cell
    float comparator = (pipeLength * pipeLength) * waterMap[pos];
    if (outputVolume <= comparator) {
        newFlowMap[pos] = float4(flowUp, flowDown, flowLeft, flowRight);
    }
    else {
        newFlowMap[pos] = float4(flowUp, flowDown, flowLeft, flowRight) * (comparator / outputVolume);
    }
}

// Compute the water height
[numthreads(8,8,1)]
void computeWaterHeight (uint3 id : SV_DispatchThreadID)
{
    int2 pos = id.xy;

    // Get the flow values of current cell and of neighbor cells
    float4 flow = flowMap[pos];
    float4 neighborFlowUp = flowMap[pos + int2(0, 1)];
    float4 neighborFlowDown = flowMap[pos + int2(0, -1)];
    float4 neighborFlowLeft = flowMap[pos + int2(-1, 0)];
    float4 neighborFlowRight = flowMap[pos + int2(1, 0)];
    
    // Calculate the flow into the current cell (take note of the directions of flow from the neighbors)
    float flowIntoCell = neighborFlowUp.y + neighborFlowDown.x + neighborFlowLeft.w + neighborFlowRight.z;

    // Calculate the flow out of the current cell
    float flowOutOfCell = flow.x + flow.y + flow.z + flow.w;

    // Calculate volume change for this cell
    float deltaVolume = flowIntoCell - flowOutOfCell;

    // Calculate new water height
    newWaterMap[pos] = waterMap[pos] + ((_deltaTime * deltaVolume) / (pipeLength * pipeLength));
}

// Compute the water velocity
[numthreads(8,8,1)]
void computeWaterVelocity (uint3 id : SV_DispatchThreadID)
{
    int2 pos = id.xy;
    
    // Get the flow of the current cell and of the neighboring cells
    float4 flow = flowMap[pos];
    float4 neighborFlowUp = flowMap[pos + int2(0, 1)];
    float4 neighborFlowDown = flowMap[pos + int2(0, -1)];
    float4 neighborFlowLeft = flowMap[pos + int2(-1, 0)];
    float4 neighborFlowRight = flowMap[pos + int2(1, 0)];
    
    // Calculate the amount of water flowing through is both directions (x is left and right and y is up and down)
    float2 averageFlow;
    averageFlow.x = (neighborFlowLeft.w - flow.w + flow.z - neighborFlowRight.z) * 0.5;
    averageFlow.y = (neighborFlowDown.x - flow.x + flow.y - neighborFlowUp.y) * 0.5;
    
    // Average water current water height and the height in the last step
    float averageWaterHeight = (newWaterMap[pos] + waterMap[pos]) * 0.5;

    // Calculate the velocity factor (I couldn't think of a better name for this...)
    float velocityFactor = pipeLength * averageWaterHeight;

    // Calculate the velocity of the water flowing through this cell
    // Round the velocity to zero if the velocity factor is very close to zero    
    velocityMap[pos] = (velocityFactor > epsilon) ? averageFlow / (pipeLength * averageWaterHeight) : float2(0, 0);
}

// Compute the diffused water velocity
[numthreads(8,8,1)]
void computeDiffusedWaterVelocity (uint3 id : SV_DispatchThreadID)
{
    int2 pos = id.xy;
    
    // Get the OLD velocity of the current cell and of the neighboring cells
    float2 velocity = velocityMap[pos];
    float2 neighborVelocityUp = velocityMap[pos + int2(0, 1)];
    float2 neighborVelocityDown = velocityMap[pos + int2(0, -1)];
    float2 neighborVelocityLeft = velocityMap[pos + int2(-1, 0)];
    float2 neighborVelocityRight = velocityMap[pos + int2(1, 0)];

    // Diffuse the current cell's velocity
    newVelocityMap[pos] = (neighborVelocityUp + neighborVelocityDown + neighborVelocityLeft + neighborVelocityRight + diffuseAlpha * velocity) / (4.0 + diffuseAlpha);
}