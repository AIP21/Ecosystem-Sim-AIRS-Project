#pragma kernel CSMain

RWTexture2D<float4> Watermap;
RWTexture2D<float4> NewWatermap;
RWTexture2D<float4> Output;
Texture2D<float> Heightmap;

int resolution;
int fillX;
int fillY;
int fillRadius;
int filling;
int maxWater;
float diffusionFactor; // Anything above about 0.2 will give an unstable simulation.

// psuedorandom number between 0 and 1
float random (float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}

float TotalHeight (int2 pos){
    // check if in bounds
    if (pos.x < 0 || pos.x >= resolution || pos.y < 0 || pos.y >= resolution)
        return 0.0;
    return Watermap[pos].r + Heightmap[pos];
}

void simWater(int2 pos){
    int x = pos.x;
    int y = pos.y;

    // Water will low from high elevation to low elevation based on the heightmap
    // Water will flow from high water to low water based on the watermap

    if(Watermap[pos].r == 0.0)
        return;

    int2 lowestNeighbor = pos;
    float lowestNeighborHeight = TotalHeight(pos);
    for (int i = 0; i < 8; i++){
        int2 neighbor = pos;
        switch (i){
            case 0:
                neighbor.x += 1;
                break;
            case 1:
                neighbor.x += 1;
                neighbor.y += 1;
                break;
            case 2:
                neighbor.y += 1;
                break;
            case 3:
                neighbor.x -= 1;
                neighbor.y += 1;
                break;
            case 4:
                neighbor.x -= 1;
                break;
            case 5:
                neighbor.x -= 1;
                neighbor.y -= 1;
                break;
            case 6:
                neighbor.y -= 1;
                break;
            case 7:
                neighbor.x += 1;
                neighbor.y -= 1;
                break;
        }
        float neighborHeight = TotalHeight(neighbor);
        if (neighborHeight < lowestNeighborHeight){
            lowestNeighbor = neighbor;
            lowestNeighborHeight = neighborHeight;
        }
    }
    
    // If the neighbor height is lower, a certain amount of water flows from this cell to the neighbor
    if (lowestNeighborHeight < TotalHeight(pos)){
        float diff = (TotalHeight(pos) - lowestNeighborHeight) * diffusionFactor;
        // diff = diff;
        NewWatermap[lowestNeighbor] = float4(Watermap[lowestNeighbor].r + diff, 0.0, 0.0, 1.0);
        NewWatermap[pos] = float4(Watermap[pos].r - diff, 0.0, 0.0, 1.0);
    }
}

[numthreads(8, 8, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;

    // Fill within circular radius of (fillX, fillY) with maxValue
    if (filling == 1 && (x - fillX) * (x - fillX) + (y - fillY) * (y - fillY) <= fillRadius * fillRadius)
    {
        NewWatermap[id.xy] = float4(1.0, 0.0, 0.0, 1.0);
        return;
    }
    
    simWater(id.xy);

    if (NewWatermap[id.xy].r > 0.0)
        Output[id.xy] = float4(NewWatermap[id.xy].r * 10, Heightmap[id.xy], Heightmap[id.xy], 1.0);
    else if (NewWatermap[id.xy].r == 0.0)
        Output[id.xy] = float4(Heightmap[id.xy], Heightmap[id.xy], Heightmap[id.xy], 1.0);
}